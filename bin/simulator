#!/usr/bin/env ruby

require 'bundler/setup'
require 'midi_visualizer'
require 'midi_visualizer/interface/simulator'

include MIDIVisualizer

PALETTE_BG = Layer::Palette.new(Color::RGB.new(0x40, 0xFF, 0x60),
                                Color::RGB.new(0x00, 0x00, 0xFF),
                                Color::RGB.new(0xFF, 0x00, 0x00))

PALETTE_FG = Layer::Palette.new(Color::RGB.new(0x00, 0x00, 0x00),
                                Color::RGB.new(0xFF, 0xFF, 0xFF))

viz = Visualizer.new Interface::Simulator.new(6, 8), PALETTE_BG, PALETTE_FG

# # Setup foreground
viz.foreground.each { |state| state.p = 1.0 }

class LFO
  def initialize(layer, f = 1.0, amplitude = 0.5, bias = 0.5)
    @func =
      lambda do |t, phase|
        amplitude * Math.cos(t * 2 * Math::PI * f + phase) + bias
      end
    @phases = Array.new(layer.num_states) { rand * 2 * Math::PI * 1.0 }
  end

  def next_state(t)
    @phases.map { |phase| @func.call(t, phase) }
  end
end

class Gauss
  def initialize(layer, f, std)
    mean_state = (rand * layer.num_states).round
    @layer = layer
    @weight_map =
      Array.new(layer.num_states) do |s|
        d = layer.distance(s, mean_state)
        Math.exp(-0.5 * (d / std)**2)
      end

    @osc_x = ->(t) { 0.5 + 0.2 * Math.cos(t * f * 2 * Math::PI) }
    @osc_y = ->(t) { 0.5 + 0.2 * Math.sin(t * f * 2 * Math::PI) }
    
    @active_notes = {}
  end
  
  def handle_midi_event(event)
    if event.on?
      @active_notes[event.note] = rand (0...@layer.num_states)
    else
      @active_notes.delete event.note
    end
  end

  def next_state(t)
    Array.new(@layer.num_states) do |i|
      x, y = @layer.position i

      dx = @osc_x.call(t) - x
      dy = @osc_y.call(t) - y

      Math.exp(-0.5 * ((dx**2 + dy**2) / 0.05))
    end
  end
end

gauss = Gauss.new viz.foreground, 0.2, 0.1
lfo_f = LFO.new viz.foreground, 0.1, 0.1, 0.9
viz.background.intensity = 0.8

router = MIDI::Router.new
router.subscribe gauss, MIDI::Event::Note

midi_process =
  Thread.new do
    loop do
      # wait a random time t
      t = rand * 5
      sleep t
      note = (rand * 10).round

      router.push({
        data: [0x90, note, 60],
        timestamp: Time.now.to_f
      })

      t = rand * 2
      sleep t

      router.push({
        data: [0x80, note, 0],
        timestamp: Time.now.to_f
      })
    end
  end

viz.run do |t, _|
  foreground_intensity = gauss.next_state(t)
  foreground_palette = lfo_f.next_state(t)
  
  router.run
  
  viz.num_states.times do |i|
    viz.foreground[i].i = foreground_intensity[i]
    viz.foreground[i].p = foreground_palette[i]
  end
end
